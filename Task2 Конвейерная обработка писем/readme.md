# ДЗ Асинхронное программирование. Конвейерная обработка писем на наличие спама

## Задача

Создать полноценный пайплайн обработки данных по аналогии с Unix пайпами, где каждая стадия представляет собой независимую функцию, принимающую данные из входного канала и передающую результаты в выходной канал. Ключевой идеей было обеспечить потоковую обработку, чтобы данные не накапливались в памяти, а сразу передавались дальше по цепочке. Это требовало правильной организации замыкания каналов и завершения горутин, чтобы избежать дедлоков.

Особенность реализации SelectUsers заключалась в необходимости дедупликации пользователей на лету. Поскольку GetUser можно вызывать параллельно для разных email, но некоторые email являются алиасами (например, batman@mail.ru и bruce.wayne@mail.ru — один пользователь), нужно было отслеживать уже обработанных пользователей.

В SelectMessages стояла задача оптимизировать запросы через батчинг. GetMessages поддерживает передачу до 2 пользователей за раз, что позволяет вдвое сократить количество вызовов. Для этого нужно было реализовать накопительный буфер, который отправляет запрос при заполнении двух пользователей, а остатки обрабатывает после завершения входного канала.

Также мок-функция HasSpam из common ограничивает 5 одновременными запросами, иначе возвращает ошибку.

Для CombineResults пришлось накапливать все результаты перед сортировкой, поскольку требуется глобальная сортировка по наличию спама и ID сообщения.

------------------------------------------------------------------------

## Что было реализовано

### 1. Архитектура конвейера (Pipeline Architecture)

Использована классическая модель pipeline:

-   каждая функция это отдельный воркер
-   вход и выход - `chan interface{}`
-   передача данных потоковая, без накопления

Реализована универсальная функция:

``` go
RunPipeline(cmds ...cmd)
```

которая создает цепочку каналов, запускает каждую команду в
отдельной горутине, соединяет выход предыдущей стадии со входом
следующей, завершает пайплайн.

------------------------------------------------------------------------

### 2. SelectUsers


Преобразование email -> `User`

**Особенности реализации:** 
- Параллельные вызовы `GetUser()`
- Учет alias-адресов (например `batman@mail.ru` ->  `bruce.wayne@mail.ru`)
- Дедупликация пользователей - Потоковая передача данных
- Один пользователь есть один `User` в выходном канале
- Нет состояния гонки при работе с мапой

------------------------------------------------------------------------

### 3. SelectMessages


`User` ->  `[]MsgID`

**Особенности реализации:** 
- Использование батчей API `GetMessages()`
- Оптимальный батчинг по 2 пользователя (в условиях к заданию было указано, что можно одновременно 2 пользователя брать)
- Параллельная обработка батчей
- Fallback-логика при ошибке батча, переход к одиночным запросам

------------------------------------------------------------------------

### 4. CheckSpam


`MsgID` ->  `MsgData{ID, HasSpam}`

**Особенности:** 
- Глобальный семафор (`globalSpamSemaphore`) на основе`chan struct{}` для функции HasSpam
- В условии задания для метода HasSpam установлен лимит параллельных запросов (антибрут): `HasSpamMaxAsyncRequests`,
поэтому используем Retry-механизм семафора с экспоненциальными повторениями запросов

------------------------------------------------------------------------

### 5. CombineResults


Формирование финального результата

**Функции:** 
- Накопление всех `MsgData`
- Сортировка: 1. По `HasSpam`(true или false) 2. По `MsgID`
- Форматирование строк  `"<has_spam> <msg_id>"`

------------------------------------------------------------------------

## Архитектурные особенности

-   Полностью потоковая модель
-   Нет накопления данных между стадиями
-   Нет глобальных блокировок пайплайна
-   Нет зависимости пайплайнов друг от друга, поддержка параллельных RunPipeline
-   Ограничение конкурентности через глобальный семафор, мьютекс, workGroup

------------------------------------------------------------------------

## Тестирование

Запуск:

``` bash
go test -v -race
```

### Покрытие:

-   Проверка stream-поведения (free-flow)
-   Проверка отсутствия накопления
-   Проверка батчинга
-   Проверка alias-логики
-   Проверка дедупликации
-   Проверка параллельных пайплайнов
-   Проверка антибрут-лимитов HasSpam
-   Проверка производительности (\< 3 сек)
-   Проверка race-condition (`-race`)

> Один тест (`TestTwoPipelinesWithHasSpam`) написан мной специально
> для проверки работы проги при нескольких пайплайнах И мок-ограничений в секунду от преподавателя
> для реализации обоих требований написал глобальный семафор для той части кода (`checkSpam`)

------------------------------------------------------------------------

## Файлы проекта

### `common.go`

Содержит: - симуляцию БД (`GetUser`) - симуляцию API сообщений
(`GetMessages`) - симуляцию антиспама (`HasSpam`) - глобальные лимиты -
статистику вызовов (`Stat`)

------------------------------------------------------------------------

### `main_test.go`

Содержит: - тесты pipeline-архитектуры - тесты асинхронности - тесты
дедлоков - тесты batching - тесты alias - тесты производительности -
тесты параллельных пайплайнов

------------------------------------------------------------------------

### `spammer.go` (моя основная работа)

- `RunPipeline` - `SelectUsers` - `SelectMessages` -
`CheckSpam` - `CombineResults` - семафоры - батчи - синхронизация -
retry-логику - сортировку - потоковая передачу данных

------------------------------------------------------------------------

## Концепции Go, использованные в проекте

-   горутины
-   канналы
-   паттер пайплайна
-   fan-out / fan-in
-   батчинг
-   семафоры через каналы
-   waitgroup
-   мьютексы
-   атомики
-   race-safe структуры
-   управление нагрузкой
-   ограниченная параллельность
-   потоковая обработка
